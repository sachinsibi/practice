<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solar System - Interactive 3D Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
        }

        /* Glass-morphism UI */
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 80px;
            height: 80px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-screen h1 {
            color: #fff;
            margin-top: 30px;
            font-weight: 300;
            letter-spacing: 4px;
        }

        #loading-screen p {
            color: rgba(255, 255, 255, 0.5);
            margin-top: 10px;
        }

        /* Top HUD */
        #top-hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #top-hud h1 {
            color: #fff;
            font-size: 18px;
            font-weight: 300;
            letter-spacing: 3px;
        }

        /* Planet Navigation */
        #planet-nav {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            z-index: 100;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90vw;
        }

        .planet-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .planet-btn:hover {
            transform: scale(1.15);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .planet-btn.active {
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
        }

        .planet-btn span {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .planet-btn:hover span {
            opacity: 1;
            bottom: -20px;
        }

        /* Planet colors */
        .planet-btn.sun { background: radial-gradient(circle at 30% 30%, #ffd700, #ff8c00, #ff4500); box-shadow: 0 0 15px rgba(255, 150, 0, 0.5); }
        .planet-btn.free-roam {
            background: linear-gradient(135deg, #1a1a3e 0%, #2d2d5e 50%, #1a1a3e 100%);
            border-style: dashed;
        }
        .planet-btn.free-roam::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
        }
        .planet-btn.free-roam::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(255,255,255,0.7);
            border-radius: 50%;
        }
        .planet-btn.mercury { background: radial-gradient(circle at 30% 30%, #b5b5b5, #8a8a8a, #5c5c5c); }
        .planet-btn.venus { background: radial-gradient(circle at 30% 30%, #ffd699, #e6b866, #cc9933); }
        .planet-btn.earth { background: radial-gradient(circle at 30% 30%, #6b93d6, #4f6d8f, #2d4a6d); }
        .planet-btn.mars { background: radial-gradient(circle at 30% 30%, #e27b58, #c1440e, #8b3103); }
        .planet-btn.jupiter { background: radial-gradient(circle at 30% 30%, #d8ca9d, #c4a66a, #a67c52); }
        .planet-btn.saturn { background: radial-gradient(circle at 30% 30%, #f4d59e, #d4a853, #c49c48); }
        .planet-btn.uranus { background: radial-gradient(circle at 30% 30%, #b5e3e3, #7fc8c8, #5dadad); }
        .planet-btn.neptune { background: radial-gradient(circle at 30% 30%, #5b7fde, #3d56a8, #2a3d7a); }

        /* Info Panel */
        #info-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 320px;
            padding: 25px;
            z-index: 100;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        #info-panel.visible {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        #info-panel h2 {
            color: #fff;
            font-size: 24px;
            font-weight: 400;
            margin-bottom: 5px;
        }

        #info-panel .subtitle {
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .info-item {
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
        }

        .info-item label {
            display: block;
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .info-item value {
            display: block;
            color: #fff;
            font-size: 14px;
        }

        #planet-description {
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            line-height: 1.6;
        }

        /* Controls Panel */
        #controls-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            padding: 20px;
            z-index: 100;
            width: 200px;
        }

        #controls-panel h3 {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .control-row label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }

        .time-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .time-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .time-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .time-btn.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        #time-display {
            color: #fff;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
        }

        /* Toggle Switch */
        .toggle {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle input:checked + .toggle-slider {
            background: rgba(255, 215, 0, 0.5);
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* Keyboard Hints */
        #keyboard-hints {
            position: fixed;
            bottom: 100px;
            left: 20px;
            padding: 15px;
            z-index: 100;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        #keyboard-hints:hover {
            opacity: 1;
        }

        .hint {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
        }

        .hint kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
            min-width: 24px;
            text-align: center;
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 11px;
            font-family: monospace;
            z-index: 100;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            #controls-panel, #keyboard-hints {
                display: none;
            }

            #info-panel {
                width: calc(100% - 40px);
                right: 20px;
                top: auto;
                bottom: 120px;
                max-height: 40vh;
                overflow-y: auto;
            }

            #planet-nav {
                bottom: 15px;
                padding: 10px 15px;
            }

            .planet-btn {
                width: 40px;
                height: 40px;
            }
        }

        /* Smooth scroll prevention */
        html, body {
            overscroll-behavior: none;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader"></div>
        <h1>SOLAR SYSTEM</h1>
        <p>Initializing...</p>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Top HUD -->
    <div id="top-hud" class="glass">
        <h1>SOLAR SYSTEM</h1>
    </div>

    <!-- FPS Counter -->
    <div id="fps-counter">60 FPS</div>

    <!-- Controls Panel -->
    <div id="controls-panel" class="glass">
        <h3>Controls</h3>

        <div class="control-group">
            <div class="control-row">
                <label>Show Orbits</label>
                <label class="toggle">
                    <input type="checkbox" id="toggle-orbits" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="control-row">
                <label>Show Labels</label>
                <label class="toggle">
                    <input type="checkbox" id="toggle-labels" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="control-row">
                <label>Asteroid Belt</label>
                <label class="toggle">
                    <input type="checkbox" id="toggle-asteroids" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="control-group">
            <div class="control-row">
                <label>Time Speed</label>
            </div>
            <div class="time-controls">
                <button class="time-btn" id="time-slower" title="Slower">-</button>
                <button class="time-btn" id="time-pause" title="Pause">&#10074;&#10074;</button>
                <button class="time-btn" id="time-faster" title="Faster">+</button>
                <button class="time-btn" id="time-reset" title="Reset">R</button>
            </div>
            <div id="time-display">1x Speed</div>
        </div>
    </div>

    <!-- Keyboard Hints -->
    <div id="keyboard-hints" class="glass">
        <div class="hint"><kbd>0</kbd> Free roam</div>
        <div class="hint"><kbd>1-9</kbd> Focus planet</div>
        <div class="hint"><kbd>Space</kbd> Pause time</div>
        <div class="hint"><kbd>+/-</kbd> Time speed</div>
        <div class="hint"><kbd>O</kbd> Toggle orbits</div>
        <div class="hint"><kbd>R</kbd> Reset view</div>
        <div class="hint"><kbd>F</kbd> Fullscreen</div>
    </div>

    <!-- Planet Navigation -->
    <div id="planet-nav" class="glass">
        <button class="planet-btn free-roam" data-planet="free" title="Free Roam"><span>Free Roam</span></button>
        <button class="planet-btn sun active" data-planet="sun" title="Sun"><span>Sun</span></button>
        <button class="planet-btn mercury" data-planet="mercury" title="Mercury"><span>Mercury</span></button>
        <button class="planet-btn venus" data-planet="venus" title="Venus"><span>Venus</span></button>
        <button class="planet-btn earth" data-planet="earth" title="Earth"><span>Earth</span></button>
        <button class="planet-btn mars" data-planet="mars" title="Mars"><span>Mars</span></button>
        <button class="planet-btn jupiter" data-planet="jupiter" title="Jupiter"><span>Jupiter</span></button>
        <button class="planet-btn saturn" data-planet="saturn" title="Saturn"><span>Saturn</span></button>
        <button class="planet-btn uranus" data-planet="uranus" title="Uranus"><span>Uranus</span></button>
        <button class="planet-btn neptune" data-planet="neptune" title="Neptune"><span>Neptune</span></button>
    </div>

    <!-- Info Panel -->
    <div id="info-panel" class="glass">
        <h2 id="planet-name">Sun</h2>
        <div class="subtitle" id="planet-type">Star</div>
        <div class="info-grid">
            <div class="info-item">
                <label>Diameter</label>
                <value id="info-diameter">1,392,700 km</value>
            </div>
            <div class="info-item">
                <label>Distance</label>
                <value id="info-distance">0 AU</value>
            </div>
            <div class="info-item">
                <label>Orbital Period</label>
                <value id="info-orbital">N/A</value>
            </div>
            <div class="info-item">
                <label>Day Length</label>
                <value id="info-day">25 Earth days</value>
            </div>
        </div>
        <p id="planet-description">The Sun is the star at the center of the Solar System. It is a nearly perfect ball of hot plasma, heated to incandescence by nuclear fusion reactions in its core.</p>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============================================
        // SOLAR SYSTEM - Interactive 3D Model
        // ============================================

        // Scene Setup
        let scene, camera, renderer;
        let planets = {};
        let orbits = {};
        let labels = {};
        let asteroidBelt;
        let starField;
        let sun;
        let sunGlow;
        let sunCorona;

        // Animation
        let clock = new THREE.Clock();
        let timeSpeed = 1;
        let isPaused = false;
        let deltaTime = 0;

        // Camera Controls
        let targetPosition = new THREE.Vector3(0, 50, 150);
        let currentTarget = new THREE.Vector3(0, 0, 0);
        let focusedPlanet = 'sun';
        let cameraDistance = 150;
        let cameraAngleX = 0;
        let cameraAngleY = 0.3;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Touch Controls
        let touchStartDistance = 0;
        let lastTouchTime = 0;

        // FPS Counter
        let frameCount = 0;
        let lastFpsUpdate = 0;

        // Planet Data (scientifically accurate ratios, scaled for visualization)
        const planetData = {
            sun: {
                name: 'Sun',
                type: 'Star',
                radius: 15,
                distance: 0,
                orbitalPeriod: 0,
                rotationPeriod: 25,
                axialTilt: 7.25,
                color: 0xffdd00,
                emissive: 0xffaa00,
                diameter: '1,392,700 km',
                distanceText: '0 AU',
                orbitalText: 'N/A',
                dayText: '25 Earth days',
                description: 'The Sun is the star at the center of the Solar System. It is a nearly perfect ball of hot plasma, heated to incandescence by nuclear fusion reactions in its core.'
            },
            mercury: {
                name: 'Mercury',
                type: 'Terrestrial Planet',
                radius: 0.8,
                distance: 30,
                orbitalPeriod: 0.24,
                rotationPeriod: 58.6,
                axialTilt: 0.03,
                color: 0xb5b5b5,
                diameter: '4,879 km',
                distanceText: '0.39 AU',
                orbitalText: '88 days',
                dayText: '59 Earth days',
                description: 'Mercury is the smallest planet in the Solar System and the closest to the Sun. Its surface is heavily cratered and similar in appearance to the Moon.'
            },
            venus: {
                name: 'Venus',
                type: 'Terrestrial Planet',
                radius: 1.5,
                distance: 45,
                orbitalPeriod: 0.62,
                rotationPeriod: -243,
                axialTilt: 177.4,
                color: 0xe6b866,
                diameter: '12,104 km',
                distanceText: '0.72 AU',
                orbitalText: '225 days',
                dayText: '243 Earth days',
                description: 'Venus is the second planet from the Sun. It has a thick, toxic atmosphere filled with carbon dioxide and is perpetually shrouded in thick clouds of sulfuric acid.'
            },
            earth: {
                name: 'Earth',
                type: 'Terrestrial Planet',
                radius: 1.6,
                distance: 60,
                orbitalPeriod: 1,
                rotationPeriod: 1,
                axialTilt: 23.4,
                color: 0x6b93d6,
                diameter: '12,742 km',
                distanceText: '1 AU',
                orbitalText: '365 days',
                dayText: '24 hours',
                description: 'Earth is the third planet from the Sun and the only astronomical object known to harbor life. About 71% of Earth\'s surface is covered with water.'
            },
            mars: {
                name: 'Mars',
                type: 'Terrestrial Planet',
                radius: 1.1,
                distance: 78,
                orbitalPeriod: 1.88,
                rotationPeriod: 1.03,
                axialTilt: 25.2,
                color: 0xc1440e,
                diameter: '6,779 km',
                distanceText: '1.52 AU',
                orbitalText: '687 days',
                dayText: '24.6 hours',
                description: 'Mars is the fourth planet from the Sun. It is often called the "Red Planet" because of its reddish appearance due to iron oxide on its surface.'
            },
            jupiter: {
                name: 'Jupiter',
                type: 'Gas Giant',
                radius: 6,
                distance: 110,
                orbitalPeriod: 11.86,
                rotationPeriod: 0.41,
                axialTilt: 3.1,
                color: 0xd8ca9d,
                diameter: '139,820 km',
                distanceText: '5.2 AU',
                orbitalText: '12 years',
                dayText: '10 hours',
                description: 'Jupiter is the largest planet in the Solar System. It is a gas giant with a mass more than two and a half times that of all the other planets combined.'
            },
            saturn: {
                name: 'Saturn',
                type: 'Gas Giant',
                radius: 5,
                distance: 145,
                orbitalPeriod: 29.46,
                rotationPeriod: 0.45,
                axialTilt: 26.7,
                color: 0xf4d59e,
                hasRings: true,
                ringInner: 6.5,
                ringOuter: 12,
                diameter: '116,460 km',
                distanceText: '9.5 AU',
                orbitalText: '29 years',
                dayText: '10.7 hours',
                description: 'Saturn is the sixth planet from the Sun and the second-largest in the Solar System. It is best known for its extensive ring system, which is mostly made of ice particles.'
            },
            uranus: {
                name: 'Uranus',
                type: 'Ice Giant',
                radius: 3,
                distance: 185,
                orbitalPeriod: 84.01,
                rotationPeriod: -0.72,
                axialTilt: 97.8,
                color: 0x7fc8c8,
                diameter: '50,724 km',
                distanceText: '19.2 AU',
                orbitalText: '84 years',
                dayText: '17 hours',
                description: 'Uranus is the seventh planet from the Sun. It has the third-largest planetary radius and fourth-largest planetary mass in the Solar System, and rotates on its side.'
            },
            neptune: {
                name: 'Neptune',
                type: 'Ice Giant',
                radius: 2.8,
                distance: 220,
                orbitalPeriod: 164.8,
                rotationPeriod: 0.67,
                axialTilt: 28.3,
                color: 0x3d56a8,
                diameter: '49,244 km',
                distanceText: '30.1 AU',
                orbitalText: '165 years',
                dayText: '16 hours',
                description: 'Neptune is the eighth and farthest planet from the Sun. It is the fourth-largest planet by diameter and the third-most-massive. Neptune has the strongest winds in the Solar System.'
            }
        };

        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 80, 180);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create scene elements
            createStarField();
            createSun();
            createPlanets();
            createAsteroidBelt();
            createOrbits();

            // Lights
            const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
            scene.add(ambientLight);

            // Event listeners
            setupEventListeners();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').classList.add('hidden');
            }, 1500);

            // Start animation
            animate();
        }

        // Create procedural starfield
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 15000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const radius = 2000 + Math.random() * 3000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);

                // Vary star colors (white, blue-white, yellow-white)
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    colors[i3] = 1;
                    colors[i3 + 1] = 1;
                    colors[i3 + 2] = 1;
                } else if (colorChoice < 0.85) {
                    colors[i3] = 0.8;
                    colors[i3 + 1] = 0.9;
                    colors[i3 + 2] = 1;
                } else {
                    colors[i3] = 1;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 0.8;
                }

                sizes[i] = Math.random() * 2 + 0.5;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starMaterial = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        // Create the Sun with hyper-realistic effects
        let sunSurface, sunFlares = [];

        function createSun() {
            const data = planetData.sun;

            // Sun core with animated procedural surface
            const sunGeometry = new THREE.SphereGeometry(data.radius, 128, 128);
            const sunMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vPosition;

                    // Simplex noise functions
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                        vec3 i  = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);

                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);

                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;

                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;

                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);

                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);

                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);

                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));

                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);

                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;

                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }

                    float fbm(vec3 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        for (int i = 0; i < 6; i++) {
                            value += amplitude * snoise(p * frequency);
                            amplitude *= 0.5;
                            frequency *= 2.0;
                        }
                        return value;
                    }

                    void main() {
                        vec3 pos = vPosition * 0.15;

                        // Animated turbulent surface
                        float t = time * 0.05;
                        float noise1 = fbm(pos + vec3(t * 0.5, t * 0.3, t * 0.2));
                        float noise2 = fbm(pos * 2.0 + vec3(t * 0.7, -t * 0.4, t * 0.6));
                        float noise3 = fbm(pos * 4.0 - vec3(t * 0.3, t * 0.5, -t * 0.4));

                        // Granulation pattern
                        float granulation = snoise(pos * 8.0 + vec3(t * 2.0)) * 0.1;

                        // Combine noises for surface detail
                        float surface = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2 + granulation;

                        // Color gradient from core to surface
                        vec3 coreColor = vec3(1.0, 1.0, 0.9);      // White-yellow core
                        vec3 midColor = vec3(1.0, 0.85, 0.2);      // Golden yellow
                        vec3 surfaceColor = vec3(1.0, 0.5, 0.1);   // Orange
                        vec3 hotSpotColor = vec3(1.0, 0.95, 0.8);  // Bright spots
                        vec3 darkSpotColor = vec3(0.9, 0.4, 0.05); // Sunspots

                        // Create color based on noise
                        float colorMix = surface * 0.5 + 0.5;
                        vec3 baseColor = mix(surfaceColor, midColor, colorMix);
                        baseColor = mix(baseColor, coreColor, pow(colorMix, 2.0));

                        // Add hot spots (bright convection cells)
                        float hotSpots = smoothstep(0.4, 0.6, noise1 + noise3 * 0.5);
                        baseColor = mix(baseColor, hotSpotColor, hotSpots * 0.4);

                        // Add darker regions (sunspot-like)
                        float darkSpots = smoothstep(0.55, 0.65, -noise2 + 0.5);
                        baseColor = mix(baseColor, darkSpotColor, darkSpots * 0.3);

                        // Limb darkening effect
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.5);
                        baseColor = mix(baseColor, surfaceColor * 0.7, fresnel * 0.4);

                        // Pulsating brightness
                        float pulse = sin(time * 0.5) * 0.05 + 1.0;
                        baseColor *= pulse;

                        gl_FragColor = vec4(baseColor, 1.0);
                    }
                `
            });

            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.name = 'sun';
            sunSurface = sunMaterial;
            scene.add(sun);
            planets.sun = sun;

            // Sun light with warm color
            const sunLight = new THREE.PointLight(0xfffaf0, 2.5, 1500);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sun.add(sunLight);

            // Inner glow layer 1 - intense core glow
            const glowGeometry1 = new THREE.SphereGeometry(data.radius * 1.08, 64, 64);
            const glowMaterial1 = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    glowColor: { value: new THREE.Color(0xffee88) },
                    viewVector: { value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        intensity = pow(0.8 - dot(vNormal, vNormel), 2.0);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    uniform float time;
                    varying float intensity;
                    varying vec2 vUv;

                    void main() {
                        float flicker = sin(time * 3.0 + vUv.x * 10.0) * 0.05 + 1.0;
                        vec3 glow = glowColor * intensity * flicker;
                        gl_FragColor = vec4(glow, intensity * 0.9);
                    }
                `,
                side: THREE.FrontSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            sunGlow = new THREE.Mesh(glowGeometry1, glowMaterial1);
            scene.add(sunGlow);

            // Middle corona layer with animated rays
            const coronaGeometry1 = new THREE.SphereGeometry(data.radius * 1.5, 64, 64);
            const coronaMaterial1 = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    glowColor: { value: new THREE.Color(0xffaa44) },
                    viewVector: { value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    uniform float time;
                    varying float intensity;
                    varying vec3 vPosition;

                    void main() {
                        vPosition = position;
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        intensity = pow(0.65 - dot(vNormal, vNormel), 2.5);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    uniform float time;
                    varying float intensity;
                    varying vec3 vPosition;

                    void main() {
                        // Create ray pattern
                        float angle = atan(vPosition.y, vPosition.x);
                        float rays = sin(angle * 12.0 + time * 0.5) * 0.3 + 0.7;
                        rays *= sin(angle * 7.0 - time * 0.3) * 0.2 + 0.8;

                        vec3 glow = glowColor * intensity * rays;
                        gl_FragColor = vec4(glow, intensity * 0.6 * rays);
                    }
                `,
                side: THREE.FrontSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            const corona1 = new THREE.Mesh(coronaGeometry1, coronaMaterial1);
            scene.add(corona1);
            sunCorona = corona1;

            // Outer corona - large diffuse glow
            const coronaGeometry2 = new THREE.SphereGeometry(data.radius * 3.0, 32, 32);
            const coronaMaterial2 = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    glowColor: { value: new THREE.Color(0xff6622) },
                    viewVector: { value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;

                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        intensity = pow(0.4 - dot(vNormal, vNormel), 3.0);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    uniform float time;
                    varying float intensity;

                    void main() {
                        float pulse = sin(time * 0.2) * 0.1 + 0.9;
                        vec3 glow = glowColor * intensity * pulse;
                        gl_FragColor = vec4(glow, intensity * 0.25);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            const corona2 = new THREE.Mesh(coronaGeometry2, coronaMaterial2);
            scene.add(corona2);

            // Store all corona layers for animation
            sun.userData.coronaLayers = [sunGlow, corona1, corona2];

            // Create solar flares / prominences
            createSolarFlares(data.radius);
        }

        // Create animated solar flares
        function createSolarFlares(sunRadius) {
            const flareCount = 5;

            for (let i = 0; i < flareCount; i++) {
                const flareGeometry = new THREE.TorusGeometry(sunRadius * 0.4, sunRadius * 0.08, 16, 32, Math.PI);
                const flareMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.6 },
                        flareColor: { value: new THREE.Color(0xff5500) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        uniform vec3 flareColor;
                        varying vec2 vUv;

                        void main() {
                            float glow = sin(vUv.x * 3.14159) * sin(vUv.y * 3.14159 * 2.0);
                            glow = pow(glow, 0.5);
                            float flicker = sin(time * 5.0 + vUv.x * 10.0) * 0.2 + 0.8;
                            vec3 color = flareColor * glow * flicker;
                            color += vec3(1.0, 0.8, 0.3) * pow(glow, 2.0) * 0.5;
                            gl_FragColor = vec4(color, glow * opacity * flicker);
                        }
                    `,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                });

                const flare = new THREE.Mesh(flareGeometry, flareMaterial);

                // Random position on sun surface
                const theta = (i / flareCount) * Math.PI * 2 + Math.random() * 0.5;
                const phi = (Math.random() - 0.5) * Math.PI * 0.6;

                flare.position.set(
                    Math.cos(theta) * Math.cos(phi) * sunRadius,
                    Math.sin(phi) * sunRadius,
                    Math.sin(theta) * Math.cos(phi) * sunRadius
                );

                // Orient flare to face outward
                flare.lookAt(flare.position.clone().multiplyScalar(2));
                flare.rotateX(Math.PI / 2);

                flare.userData = {
                    baseTheta: theta,
                    basePhi: phi,
                    speed: 0.1 + Math.random() * 0.2,
                    scale: 0.5 + Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2
                };

                scene.add(flare);
                sunFlares.push(flare);
            }
        }

        // Create all planets
        function createPlanets() {
            Object.keys(planetData).forEach(key => {
                if (key === 'sun') return;

                const data = planetData[key];
                const geometry = new THREE.SphereGeometry(data.radius, 64, 64);

                // Create planet material with better lighting response
                const material = new THREE.MeshStandardMaterial({
                    color: data.color,
                    roughness: 0.8,
                    metalness: 0.1
                });

                const planet = new THREE.Mesh(geometry, material);
                planet.name = key;
                planet.castShadow = true;
                planet.receiveShadow = true;

                // Set initial position
                planet.userData = {
                    distance: data.distance,
                    orbitalPeriod: data.orbitalPeriod,
                    rotationPeriod: data.rotationPeriod,
                    angle: Math.random() * Math.PI * 2,
                    axialTilt: data.axialTilt * Math.PI / 180
                };

                // Apply axial tilt
                planet.rotation.z = planet.userData.axialTilt;

                scene.add(planet);
                planets[key] = planet;

                // Create rings for Saturn
                if (data.hasRings) {
                    createRings(planet, data);
                }

                // Create atmosphere for Earth
                if (key === 'earth') {
                    createAtmosphere(planet, data);
                }
            });
        }

        // Create Saturn's rings
        function createRings(planet, data) {
            const ringGeometry = new THREE.RingGeometry(data.ringInner, data.ringOuter, 128);

            // Rotate UVs for proper texture mapping
            const pos = ringGeometry.attributes.position;
            const uv = ringGeometry.attributes.uv;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const dist = Math.sqrt(x * x + y * y);
                const normalizedDist = (dist - data.ringInner) / (data.ringOuter - data.ringInner);
                uv.setXY(i, normalizedDist, 1);
            }

            // Create ring gradient
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 512, 0);
            gradient.addColorStop(0, 'rgba(180, 160, 140, 0.1)');
            gradient.addColorStop(0.2, 'rgba(200, 180, 150, 0.6)');
            gradient.addColorStop(0.35, 'rgba(160, 140, 120, 0.2)');
            gradient.addColorStop(0.4, 'rgba(180, 160, 140, 0.7)');
            gradient.addColorStop(0.6, 'rgba(200, 180, 160, 0.5)');
            gradient.addColorStop(0.7, 'rgba(140, 120, 100, 0.3)');
            gradient.addColorStop(0.85, 'rgba(180, 160, 140, 0.4)');
            gradient.addColorStop(1, 'rgba(160, 140, 120, 0.1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 16);

            const ringTexture = new THREE.CanvasTexture(canvas);

            const ringMaterial = new THREE.MeshBasicMaterial({
                map: ringTexture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            const rings = new THREE.Mesh(ringGeometry, ringMaterial);
            rings.rotation.x = Math.PI / 2;
            rings.rotation.y = planet.userData.axialTilt;
            planet.add(rings);
        }

        // Create Earth's atmosphere
        function createAtmosphere(planet, data) {
            const atmosphereGeometry = new THREE.SphereGeometry(data.radius * 1.05, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0x88ccff) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        gl_FragColor = vec4(glowColor, intensity * 0.5);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            planet.add(atmosphere);
        }

        // Create asteroid belt
        function createAsteroidBelt() {
            const asteroidCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(asteroidCount * 3);
            const colors = new Float32Array(asteroidCount * 3);
            const sizes = new Float32Array(asteroidCount);

            for (let i = 0; i < asteroidCount; i++) {
                const i3 = i * 3;
                const angle = Math.random() * Math.PI * 2;
                const distance = 90 + Math.random() * 15; // Between Mars and Jupiter
                const height = (Math.random() - 0.5) * 5;

                positions[i3] = Math.cos(angle) * distance;
                positions[i3 + 1] = height;
                positions[i3 + 2] = Math.sin(angle) * distance;

                // Gray-brown colors
                const shade = 0.3 + Math.random() * 0.4;
                colors[i3] = shade;
                colors[i3 + 1] = shade * 0.9;
                colors[i3 + 2] = shade * 0.8;

                sizes[i] = Math.random() * 0.5 + 0.1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            asteroidBelt = new THREE.Points(geometry, material);
            scene.add(asteroidBelt);
        }

        // Create orbital paths
        function createOrbits() {
            Object.keys(planetData).forEach(key => {
                if (key === 'sun') return;

                const data = planetData[key];
                const curve = new THREE.EllipseCurve(
                    0, 0,
                    data.distance, data.distance,
                    0, 2 * Math.PI,
                    false,
                    0
                );

                const points = curve.getPoints(256);
                const geometry = new THREE.BufferGeometry().setFromPoints(
                    points.map(p => new THREE.Vector3(p.x, 0, p.y))
                );

                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.15
                });

                const orbit = new THREE.Line(geometry, material);
                scene.add(orbit);
                orbits[key] = orbit;
            });
        }

        // Setup event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onMouseClick);

            // Touch controls
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // Keyboard controls
            document.addEventListener('keydown', onKeyDown);

            // Planet navigation buttons
            document.querySelectorAll('.planet-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    focusOnPlanet(btn.dataset.planet);
                });
            });

            // Toggle controls
            document.getElementById('toggle-orbits').addEventListener('change', (e) => {
                Object.values(orbits).forEach(orbit => {
                    orbit.visible = e.target.checked;
                });
            });

            document.getElementById('toggle-asteroids').addEventListener('change', (e) => {
                asteroidBelt.visible = e.target.checked;
            });

            // Time controls
            document.getElementById('time-slower').addEventListener('click', () => {
                timeSpeed = Math.max(0.1, timeSpeed / 2);
                updateTimeDisplay();
            });

            document.getElementById('time-faster').addEventListener('click', () => {
                timeSpeed = Math.min(100, timeSpeed * 2);
                updateTimeDisplay();
            });

            document.getElementById('time-pause').addEventListener('click', () => {
                isPaused = !isPaused;
                document.getElementById('time-pause').classList.toggle('active', isPaused);
                document.getElementById('time-pause').innerHTML = isPaused ? '&#9658;' : '&#10074;&#10074;';
            });

            document.getElementById('time-reset').addEventListener('click', () => {
                timeSpeed = 1;
                updateTimeDisplay();
            });
        }

        function updateTimeDisplay() {
            document.getElementById('time-display').textContent = timeSpeed + 'x Speed';
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Mouse handlers
        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            cameraAngleX -= deltaX * 0.005;
            cameraAngleY = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraAngleY + deltaY * 0.005));

            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseWheel(e) {
            e.preventDefault();
            cameraDistance *= 1 + e.deltaY * 0.001;
            cameraDistance = Math.max(10, Math.min(500, cameraDistance));
        }

        function onMouseClick(e) {
            if (isDragging) return;

            // Raycast to detect planet clicks
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const planetMeshes = Object.values(planets);
            const intersects = raycaster.intersectObjects(planetMeshes);

            if (intersects.length > 0) {
                focusOnPlanet(intersects[0].object.name);
            }
        }

        // Touch handlers
        function onTouchStart(e) {
            e.preventDefault();

            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };

                // Double tap detection
                const now = Date.now();
                if (now - lastTouchTime < 300) {
                    // Double tap - focus on nearest planet
                    const touch = e.touches[0];
                    const mouse = new THREE.Vector2(
                        (touch.clientX / window.innerWidth) * 2 - 1,
                        -(touch.clientY / window.innerHeight) * 2 + 1
                    );
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(Object.values(planets));
                    if (intersects.length > 0) {
                        focusOnPlanet(intersects[0].object.name);
                    }
                }
                lastTouchTime = now;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function onTouchMove(e) {
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - previousMousePosition.x;
                const deltaY = e.touches[0].clientY - previousMousePosition.y;

                cameraAngleX -= deltaX * 0.005;
                cameraAngleY = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraAngleY + deltaY * 0.005));

                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (touchStartDistance > 0) {
                    const scale = touchStartDistance / distance;
                    cameraDistance *= scale;
                    cameraDistance = Math.max(10, Math.min(500, cameraDistance));
                }

                touchStartDistance = distance;
            }
        }

        function onTouchEnd() {
            isDragging = false;
            touchStartDistance = 0;
        }

        // Keyboard handler
        function onKeyDown(e) {
            switch(e.key) {
                case '0': focusOnPlanet('free'); break;
                case '1': focusOnPlanet('sun'); break;
                case '2': focusOnPlanet('mercury'); break;
                case '3': focusOnPlanet('venus'); break;
                case '4': focusOnPlanet('earth'); break;
                case '5': focusOnPlanet('mars'); break;
                case '6': focusOnPlanet('jupiter'); break;
                case '7': focusOnPlanet('saturn'); break;
                case '8': focusOnPlanet('uranus'); break;
                case '9': focusOnPlanet('neptune'); break;
                case ' ':
                    e.preventDefault();
                    isPaused = !isPaused;
                    document.getElementById('time-pause').classList.toggle('active', isPaused);
                    document.getElementById('time-pause').innerHTML = isPaused ? '&#9658;' : '&#10074;&#10074;';
                    break;
                case '+':
                case '=':
                    timeSpeed = Math.min(100, timeSpeed * 2);
                    updateTimeDisplay();
                    break;
                case '-':
                    timeSpeed = Math.max(0.1, timeSpeed / 2);
                    updateTimeDisplay();
                    break;
                case 'o':
                case 'O':
                    const orbitsToggle = document.getElementById('toggle-orbits');
                    orbitsToggle.checked = !orbitsToggle.checked;
                    Object.values(orbits).forEach(orbit => {
                        orbit.visible = orbitsToggle.checked;
                    });
                    break;
                case 'r':
                case 'R':
                    focusOnPlanet('sun');
                    cameraDistance = 150;
                    cameraAngleX = 0;
                    cameraAngleY = 0.3;
                    break;
                case 'f':
                case 'F':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                    break;
            }
        }

        // Free roam mode
        let isFreeRoam = false;
        let freeRoamTarget = new THREE.Vector3(0, 0, 0);

        // Focus on a planet or enter free roam
        function focusOnPlanet(planetName) {
            // Handle free roam mode
            if (planetName === 'free') {
                isFreeRoam = true;
                focusedPlanet = null;

                // Update UI - deselect all planets
                document.querySelectorAll('.planet-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.planet === 'free');
                });

                // Hide info panel
                document.getElementById('info-panel').classList.remove('visible');

                // Set camera to look at center of solar system
                freeRoamTarget.set(0, 0, 0);
                cameraDistance = 250;
                return;
            }

            // Normal planet focus
            isFreeRoam = false;
            focusedPlanet = planetName;

            // Update UI
            document.querySelectorAll('.planet-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.planet === planetName);
            });

            // Update info panel
            const data = planetData[planetName];
            document.getElementById('planet-name').textContent = data.name;
            document.getElementById('planet-type').textContent = data.type;
            document.getElementById('info-diameter').textContent = data.diameter;
            document.getElementById('info-distance').textContent = data.distanceText;
            document.getElementById('info-orbital').textContent = data.orbitalText;
            document.getElementById('info-day').textContent = data.dayText;
            document.getElementById('planet-description').textContent = data.description;

            document.getElementById('info-panel').classList.add('visible');

            // Adjust camera distance based on planet size
            const targetDistance = planetName === 'sun' ? 80 : data.radius * 15 + 20;
            cameraDistance = targetDistance;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            deltaTime = clock.getDelta();

            // FPS counter
            frameCount++;
            if (clock.elapsedTime - lastFpsUpdate >= 1) {
                document.getElementById('fps-counter').textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsUpdate = clock.elapsedTime;
            }

            const elapsedTime = clock.elapsedTime;

            if (!isPaused) {
                const time = elapsedTime * timeSpeed;

                // Animate planets
                Object.keys(planets).forEach(key => {
                    const planet = planets[key];
                    const data = planet.userData;

                    if (key !== 'sun' && data.orbitalPeriod) {
                        // Orbital motion
                        data.angle += (deltaTime * timeSpeed * 0.1) / data.orbitalPeriod;
                        planet.position.x = Math.cos(data.angle) * data.distance;
                        planet.position.z = Math.sin(data.angle) * data.distance;
                    }

                    // Rotation
                    if (data.rotationPeriod) {
                        planet.rotation.y += (deltaTime * timeSpeed * 0.5) / Math.abs(data.rotationPeriod);
                    }
                });

                // Rotate asteroid belt slowly
                if (asteroidBelt) {
                    asteroidBelt.rotation.y += deltaTime * timeSpeed * 0.002;
                }
            }

            // Animate sun surface (always animate for visual appeal)
            if (sunSurface && sunSurface.uniforms) {
                sunSurface.uniforms.time.value = elapsedTime;
            }

            // Animate sun glow and corona layers
            if (sunGlow && sunGlow.material.uniforms) {
                sunGlow.material.uniforms.viewVector.value = camera.position;
                sunGlow.material.uniforms.time.value = elapsedTime;
            }
            if (sunCorona && sunCorona.material.uniforms) {
                sunCorona.material.uniforms.viewVector.value = camera.position;
                sunCorona.material.uniforms.time.value = elapsedTime;
            }

            // Animate all corona layers
            if (sun && sun.userData.coronaLayers) {
                sun.userData.coronaLayers.forEach(layer => {
                    if (layer.material.uniforms) {
                        if (layer.material.uniforms.time) {
                            layer.material.uniforms.time.value = elapsedTime;
                        }
                        if (layer.material.uniforms.viewVector) {
                            layer.material.uniforms.viewVector.value = camera.position;
                        }
                    }
                });
            }

            // Animate solar flares
            sunFlares.forEach((flare, index) => {
                if (flare.material.uniforms) {
                    flare.material.uniforms.time.value = elapsedTime;

                    // Pulsating opacity
                    const pulse = Math.sin(elapsedTime * flare.userData.speed + flare.userData.phase) * 0.3 + 0.5;
                    flare.material.uniforms.opacity.value = pulse * flare.userData.scale;
                }

                // Slowly rotate flares around sun
                if (!isPaused) {
                    const sunRadius = planetData.sun.radius;
                    flare.userData.baseTheta += deltaTime * 0.02 * flare.userData.speed;
                    const theta = flare.userData.baseTheta;
                    const phi = flare.userData.basePhi;

                    flare.position.set(
                        Math.cos(theta) * Math.cos(phi) * sunRadius,
                        Math.sin(phi) * sunRadius,
                        Math.sin(theta) * Math.cos(phi) * sunRadius
                    );
                    flare.lookAt(flare.position.clone().multiplyScalar(2));
                    flare.rotateX(Math.PI / 2);
                }
            });

            // Update camera position
            if (isFreeRoam) {
                // Free roam mode - orbit around center of solar system
                currentTarget.lerp(freeRoamTarget, 0.03);

                const camX = currentTarget.x + Math.sin(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
                const camY = currentTarget.y + Math.sin(cameraAngleY) * cameraDistance;
                const camZ = currentTarget.z + Math.cos(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;

                camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.05);
                camera.lookAt(currentTarget);
            } else {
                const focusTarget = planets[focusedPlanet];
                if (focusTarget) {
                    // Smooth camera target transition
                    currentTarget.lerp(focusTarget.position, 0.05);

                    // Calculate camera position
                    const camX = currentTarget.x + Math.sin(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;
                    const camY = currentTarget.y + Math.sin(cameraAngleY) * cameraDistance;
                    const camZ = currentTarget.z + Math.cos(cameraAngleX) * Math.cos(cameraAngleY) * cameraDistance;

                    camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.08);
                    camera.lookAt(currentTarget);
                }
            }

            // Slowly rotate starfield for immersion
            if (starField) {
                starField.rotation.y += deltaTime * 0.001;
            }

            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>
